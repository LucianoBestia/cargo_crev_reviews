initSidebarItems({"fn":[["cargo_registry_cache_file_for_crate","cargo registry cache file `.crate` for a crate"],["cargo_registry_src_dir","cargo registry src directory for a crate"],["cargo_registry_src_dir_for_crate","cargo registry src directory for a crate"],["compare_src_and_cache_content",""],["download_crate_from_crate_io","download url from crates.io into `cargo registry cache` folder like: https://crates.io/api/v1/crates/block-cipher-trait/0.6.0/download it works also for yanked crates. This downloads are immutable."],["fix_missing_src_folder_for_crates_that_have_review","when we are writing reviews, the source code of the crate must be locally in the `src` folder. In that time it is a dependency of our project, so `cargo build` has downloaded the crates. But later this source code can be removed because all our projects will use newer versions. If we want to check that the reviews have the correct digest, we need the old source code. I donâ€™t want to use cargo as a library (for now). And there is not a raw CLI command to download and unpack a crate. First I will check if the crate_version is in the `src` folder. If not try to unpack it. If it does not exist neither in the `cache` folder, then download it like `https://crates.io/api/v1/crates/block-cipher-trait/0.6.0/download` This works also for yanked crates."],["info_for_one_crate","info of all versions for one crate"],["list_unclean_crates","compare the files in `src` and `cache` folders of `cargo registry` return a list of folders to delete and on the end the user will call `cargo check` to re-create a fresh copy of these folders"],["max_version_from_registry_index","max version from registry index cache"],["open_index",""],["unpack_from_cache_to_src","unpack the .crate file from the `cache` to the `src` folder"],["update_registry_index","fetch/pull the registry index from github"],["yanked_for_one_crate","list only yanked versions for one crate"],["yanked_for_version","yanked"]],"struct":[["FileMetadata",""]]});